<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sense360 Firmware Configuration Tool</title>
    <link rel="icon" type="image/png" sizes="32x32" href="./sense360-favicon-32.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/wizard-style.css?v=1753432000">
    <link rel="stylesheet" href="css/capability-bar.css">
    <link rel="stylesheet" href="css/theme.css">
    <link rel="stylesheet" href="css/layout.css">
    <script type="module" src="https://unpkg.com/esp-web-tools@9/dist/web/install-button.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-container">
                <img src="sense360-logo-new.png" alt="Sense360 Logo" class="logo">
                <div class="header-text">
                    <h1>Sense360 Firmware Configuration Tool</h1>
                    <p class="subtitle">Configure and download the correct firmware for your modular hardware</p>
                </div>
            </div>
        </header>

        <div class="wizard-container">
            <div class="wizard-layout wizard-layout--two-column">
                <div class="wizard-main">
                    <!-- Progress Indicator -->
                    <div class="progress-bar">
                <div class="progress-step active" data-step="1">
                    <div class="step-number">1</div>
                    <div class="step-label">Mounting</div>
                </div>
                <div class="progress-step" data-step="2">
                    <div class="step-number">2</div>
                    <div class="step-label">Power</div>
                </div>
                <div class="progress-step" data-step="3">
                    <div class="step-number">3</div>
                    <div class="step-label">Modules</div>
                </div>
                <div class="progress-step" data-step="4">
                    <div class="step-number">4</div>
                    <div class="step-label">Review</div>
                </div>
                    </div>

                    <!-- Step 1: Mounting Type -->
                    <div class="wizard-step active" id="step-1">
                <h2>Step 1: Where is this unit being installed?</h2>
                <div class="option-grid">
                    <label class="option-card">
                        <input type="radio" name="mounting" value="wall">
                        <div class="option-content">
                            <div class="option-title">Wall Mount</div>
                            <div class="option-description">Standard wall installation with full module support</div>
                        </div>
                    </label>
                    <label class="option-card">
                        <input type="radio" name="mounting" value="ceiling">
                        <div class="option-content">
                            <div class="option-title">Ceiling Mount</div>
                            <div class="option-description">Ceiling installation (Fan Module not available)</div>
                        </div>
                    </label>
                </div>
                <div class="wizard-actions">
                    <button class="btn btn-primary btn-next" onclick="nextStep()" disabled>Next</button>
                </div>
                    </div>

                    <!-- Step 2: Power Option -->
                    <div class="wizard-step" id="step-2">
                <h2>Step 2: Select Power Option</h2>
                <div class="option-grid">
                    <label class="option-card">
                        <input type="radio" name="power" value="usb">
                        <div class="option-content">
                            <div class="option-title">USB Power</div>
                            <div class="option-description">Standard USB-C power connection</div>
                        </div>
                    </label>
                    <label class="option-card">
                        <input type="radio" name="power" value="poe">
                        <div class="option-content">
                            <div class="option-title">POE Module</div>
                            <div class="option-description">Power over Ethernet module</div>
                        </div>
                    </label>
                    <label class="option-card">
                        <input type="radio" name="power" value="pwr">
                        <div class="option-content">
                            <div class="option-title">PWR Module</div>
                            <div class="option-description">External power module</div>
                        </div>
                    </label>
                </div>
                <div class="wizard-actions">
                    <button class="btn btn-secondary" onclick="previousStep()">Back</button>
                    <button class="btn btn-primary btn-next" onclick="nextStep()" disabled>Next</button>
                </div>
                    </div>

                <!-- Step 3: Expansion Modules -->
                <div class="wizard-step" id="step-3">
                <h2>Step 3: Add Expansion Modules</h2>
                <div class="module-availability-hint" id="module-availability-hint" role="status" aria-live="polite">
                    Select a mounting and power option to see supported expansion modules.
                </div>

                <!-- AirIQ Module -->
                <div class="module-section">
                    <h3>AirIQ Module</h3>
                    <div class="option-grid">
                        <label class="option-card">
                            <input type="radio" name="airiq" value="none" checked>
                            <div class="option-content">
                                <div class="option-title">None</div>
                                <div class="option-description">No AirIQ module</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="airiq" value="base">
                            <div class="option-content">
                                <div class="option-title">Base</div>
                                <div class="option-description">SGP41, SCD41, MiCS4514, BMP390</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="airiq" value="pro">
                            <div class="option-content">
                                <div class="option-title">Pro</div>
                                <div class="option-description">All Base + SEN0321, SPS30, SFA40</div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Presence Module -->
                <div class="module-section">
                    <h3>Presence Module</h3>
                    <div class="option-grid">
                        <label class="option-card">
                            <input type="radio" name="presence" value="none" checked>
                            <div class="option-content">
                                <div class="option-title">None</div>
                                <div class="option-description">No Presence module</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="presence" value="base">
                            <div class="option-content">
                                <div class="option-title">Base</div>
                                <div class="option-description">SEN0609 mmWave sensor</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="presence" value="pro">
                            <div class="option-content">
                                <div class="option-title">Pro</div>
                                <div class="option-description">SEN0609 + LD2450 radar</div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Comfort Module -->
                <div class="module-section">
                    <h3>Comfort Module</h3>
                    <div class="option-grid">
                        <label class="option-card">
                            <input type="radio" name="comfort" value="none" checked>
                            <div class="option-content">
                                <div class="option-title">None</div>
                                <div class="option-description">No Comfort module</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="comfort" value="base">
                            <div class="option-content">
                                <div class="option-title">Base</div>
                                <div class="option-description">SHT40 + LTR-303 sensors</div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- Fan Module (only for wall mount) -->
                <div class="module-section" id="fan-module-section">
                    <h3>Fan Module</h3>
                    <div class="option-grid">
                        <label class="option-card">
                            <input type="radio" name="fan" value="none" checked>
                            <div class="option-content">
                                <div class="option-title">None</div>
                                <div class="option-description">No Fan module</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="fan" value="pwm">
                            <div class="option-content">
                                <div class="option-title">PWM</div>
                                <div class="option-description">Variable speed fan control</div>
                            </div>
                        </label>
                        <label class="option-card">
                            <input type="radio" name="fan" value="analog">
                            <div class="option-content">
                                <div class="option-title">Analog</div>
                                <div class="option-description">0-10V analog fan control</div>
                            </div>
                        </label>
                    </div>
                </div>

                <div class="remember-preference">
                    <label class="remember-toggle">
                        <input type="checkbox" data-remember-toggle>
                        <span class="remember-label">Remember my last choices</span>
                    </label>
                </div>

                <div class="wizard-actions">
                    <button class="btn btn-secondary" onclick="previousStep()">Back</button>
                    <button class="btn btn-primary btn-next" onclick="nextStep()">Next</button>
                </div>
                    </div>

                    <!-- Step 4: Review & Download -->
                    <div class="wizard-step" id="step-4">
                <h2>Step 4: Review & Download</h2>
                
                <div class="configuration-summary">
                    <h3>Your Configuration</h3>
                    <div id="config-summary">
                        <!-- Summary will be populated by JavaScript -->
                    </div>
                </div>

                <section class="pre-flash-checklist" aria-labelledby="pre-flash-title">
                    <h3 class="checklist-heading" id="pre-flash-title">Pre-Flash Checklist</h3>
                    <p class="checklist-subtitle">Follow these quick steps to prepare your device before installing firmware.</p>
                    <ul class="checklist-items">
                        <li data-checklist-item data-complete="false">
                            <span class="status-icon" aria-hidden="true"></span>
                            <span class="item-text">Connect the Sense360 hub to your computer with a USB-C cable.</span>
                        </li>
                        <li data-checklist-item data-complete="false">
                            <span class="status-icon" aria-hidden="true"></span>
                            <span class="item-text">Hold the <strong>BOOT</strong> button on the hub.</span>
                        </li>
                        <li data-checklist-item data-complete="false">
                            <span class="status-icon" aria-hidden="true"></span>
                            <span class="item-text">While holding BOOT, press and release <strong>RESET</strong>, then release BOOT.</span>
                        </li>
                    </ul>
                </section>

                <div class="firmware-section">
                    <h3>Compatible Firmware</h3>
                    <div class="firmware-selector" id="firmware-selector" hidden>
                        <label class="firmware-selector-label" for="firmware-version-select">Select firmware release</label>
                        <select id="firmware-version-select" class="firmware-selector-control" aria-label="Available firmware releases"></select>
                    </div>
                    <div id="compatible-firmware">
                        <!-- Compatible firmware will be shown here -->
                    </div>
                </div>

                <div class="remember-preference">
                    <label class="remember-toggle">
                        <input type="checkbox" data-remember-toggle>
                        <span class="remember-label">Remember my last choices</span>
                    </label>
                </div>

                <div class="wizard-actions">
                    <button class="btn btn-secondary" onclick="previousStep()">Back</button>
                    <div class="primary-action-group">
                        <div class="primary-action-controls">
                            <button class="btn btn-primary" id="download-btn" onclick="downloadFirmware()" disabled>Download Firmware</button>
                            <button class="btn btn-icon" id="copy-firmware-url-btn" type="button" onclick="copyFirmwareUrl()" aria-label="Copy firmware link" disabled>
                                <svg aria-hidden="true" viewBox="0 0 24 24" focusable="false">
                                    <path d="M10.59 13.41a4 4 0 0 1 5.66 0l1.18 1.18a4 4 0 0 1 0 5.66l-2 2a4 4 0 0 1-5.66 0" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
                                    <path d="M13.41 10.59a4 4 0 0 1-5.66 0L6.59 9.43a4 4 0 0 1 0-5.66l2-2a4 4 0 0 1 5.66 0" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
                                </svg>
                            </button>
                        </div>
                        <p class="ready-helper" data-ready-helper role="status" aria-live="polite"></p>
                    </div>
                </div>
                    </div>
                </div>

            </div>
        </div>

        <div class="browser-check">
            <div class="browser-warning" id="browser-warning" style="display: none;">
                <h3>⚠️ Browser Not Supported</h3>
                <p>This installer requires Chrome or Edge browser with Web Serial API support.</p>
            </div>
        </div>
    </div>

    <script src="scripts/support/errors.js"></script>
    <script src="scripts/support/boundary.js"></script>
    <script src="scripts/wizard-state-observer.js"></script>
    <script type="module" src="scripts/state.js"></script>
    <script type="module" src="scripts/query-presets.js"></script>
    <script type="module" src="scripts/support/ui.js"></script>
    <script>
        let currentStep = 1;
        const totalSteps = 4;
        const defaultConfiguration = {
            mounting: null,
            power: null,
            airiq: 'none',
            presence: 'none',
            comfort: 'none',
            fan: 'none'
        };
        const configuration = { ...defaultConfiguration };
        const FIRMWARE_CHANNEL_ORDER = {
            stable: 0,
            general: 0,
            release: 0,
            beta: 1,
            preview: 1,
            ga: 1,
            dev: 2,
            nightly: 2,
            canary: 2
        };
        const FIRMWARE_CHANNEL_LABELS = {
            stable: 'Stable',
            general: 'General',
            release: 'Release',
            beta: 'Beta',
            preview: 'Preview',
            ga: 'Preview',
            dev: 'Dev',
            nightly: 'Nightly',
            canary: 'Canary'
        };
        let currentFirmwareOptions = [];
        let firmwareOptionsMap = new Map();
        let currentFirmwareSelectionId = null;
        const PREF_KEYS = {
            rememberChoices: 'sense360.rememberChoices',
            lastWizardState: 'sense360.lastWizardState'
        };

        let rememberToggleInputs = [];
        const allowedOptions = {
            mounting: ['wall', 'ceiling'],
            power: ['usb', 'poe', 'pwr'],
            airiq: ['none', 'base', 'pro'],
            presence: ['none', 'base', 'pro'],
            comfort: ['none', 'base'],
            fan: ['none', 'pwm', 'analog']
        };

        const MODULE_SEGMENT_FORMATTERS = {
            airiq: value => `AirIQ${value.charAt(0).toUpperCase() + value.slice(1)}`,
            presence: value => `Presence${value === 'base' ? '' : value.charAt(0).toUpperCase() + value.slice(1)}`,
            comfort: value => `Comfort${value === 'base' ? '' : value.charAt(0).toUpperCase() + value.slice(1)}`,
            fan: value => `Fan${value.toUpperCase()}`
        };

        function formatConfigSegment(moduleKey, moduleValue) {
            const key = (moduleKey || '').toString().trim().toLowerCase();
            const value = (moduleValue || '').toString().trim().toLowerCase();

            if (!key || !value || value === 'none') {
                return '';
            }

            const formatter = MODULE_SEGMENT_FORMATTERS[key];
            if (!formatter) {
                return '';
            }

            const segment = formatter(value);
            if (!segment) {
                return '';
            }

            return `-${segment}`;
        }

        let checklistCompleted = false;
        let toastTimeoutId = null;

        function getPreferenceStorage() {
            try {
                return window.localStorage;
            } catch (error) {
                console.warn('Local storage is not available:', error);
                return null;
            }
        }

        function getPreference(key, defaultValue = null) {
            const storage = getPreferenceStorage();
            if (!storage) {
                return defaultValue;
            }

            try {
                const rawValue = storage.getItem(key);
                if (rawValue === null) {
                    return defaultValue;
                }
                return JSON.parse(rawValue);
            } catch (error) {
                console.warn('Failed to read stored preference', key, error);
                return defaultValue;
            }
        }

        function setPreference(key, value) {
            const storage = getPreferenceStorage();
            if (!storage) {
                return;
            }

            try {
                if (value === null || value === undefined) {
                    storage.removeItem(key);
                } else {
                    storage.setItem(key, JSON.stringify(value));
                }
            } catch (error) {
                console.warn('Failed to persist preference', key, error);
            }
        }

        function isRememberEnabled() {
            return Boolean(getPreference(PREF_KEYS.rememberChoices, false));
        }

        function setRememberEnabled(enabled) {
            setPreference(PREF_KEYS.rememberChoices, Boolean(enabled));
        }

        function normalizeRememberedConfiguration(rawConfig) {
            if (!rawConfig || typeof rawConfig !== 'object' || Array.isArray(rawConfig)) {
                return null;
            }

            const normalized = { ...defaultConfiguration };
            let hasPersistedValue = false;

            Object.keys(defaultConfiguration).forEach(key => {
                if (!(key in rawConfig)) {
                    return;
                }

                const value = rawConfig[key];
                const defaultValue = defaultConfiguration[key];

                if (value === null) {
                    if (defaultValue === null) {
                        normalized[key] = null;
                    }
                    return;
                }

                const allowed = allowedOptions[key];
                if (allowed && allowed.includes(value)) {
                    normalized[key] = value;
                    if (value !== defaultValue) {
                        hasPersistedValue = true;
                    }
                }
            });

            return hasPersistedValue ? normalized : null;
        }

        function loadRememberedConfiguration() {
            const rawConfig = getPreference(PREF_KEYS.lastWizardState, null);
            const normalized = normalizeRememberedConfiguration(rawConfig);

            if (!normalized && rawConfig) {
                clearRememberedConfiguration();
            }

            return normalized;
        }

        function persistConfigurationSnapshot() {
            if (!isRememberEnabled()) {
                return;
            }

            const snapshot = {};
            Object.keys(defaultConfiguration).forEach(key => {
                const value = configuration[key];
                snapshot[key] = value === undefined ? defaultConfiguration[key] : value;
            });
            setPreference(PREF_KEYS.lastWizardState, snapshot);
        }

        function clearRememberedConfiguration() {
            setPreference(PREF_KEYS.lastWizardState, null);
        }

        function syncRememberToggleState(enabled) {
            rememberToggleInputs.forEach(input => {
                if (input.checked !== enabled) {
                    input.checked = enabled;
                }
            });
        }

        function handleRememberToggleChange(event) {
            const enabled = event.target.checked;
            setRememberEnabled(enabled);
            syncRememberToggleState(enabled);

            if (enabled) {
                persistConfigurationSnapshot();
            } else {
                clearRememberedConfiguration();
            }
        }

        function runStepRender(stepElement, stepNumber, renderFn) {
            const boundary = window.supportBoundary;
            const render = typeof renderFn === 'function' ? renderFn : null;

            if (boundary && typeof boundary.render === 'function') {
                return boundary.render(stepElement, {
                    stepId: stepElement ? stepElement.id : `step-${stepNumber}`,
                    stepNumber,
                    render
                });
            }

            if (!render) {
                return { ok: true, skipped: true };
            }

            try {
                render();
                return { ok: true };
            } catch (error) {
                console.error(`[wizard] Step ${stepNumber} render failed`, error);
                return { ok: false, error };
            }
        }

        function syncChecklistCompletion() {
            const section = document.querySelector('.pre-flash-checklist');
            if (!section) return;

            const completionValue = checklistCompleted ? 'true' : 'false';
            section.dataset.complete = completionValue;

            section.querySelectorAll('[data-checklist-item]').forEach(item => {
                item.dataset.complete = completionValue;
            });
        }

        function setChecklistCompletion(isComplete) {
            checklistCompleted = isComplete;
            syncChecklistCompletion();
        }

        function attachInstallButtonListeners() {
            const selectors = [
                '#compatible-firmware esp-web-install-button button[slot="activate"]',
                '#legacy-firmware-list esp-web-install-button button[slot="activate"]'
            ];
            const installButtons = document.querySelectorAll(selectors.join(', '));
            installButtons.forEach(button => {
                if (button.dataset.checklistBound === 'true') {
                    return;
                }
                button.addEventListener('click', () => {
                    const card = button.closest('[data-firmware-card]');
                    if (card && card.dataset.firmwareId) {
                        selectFirmwareById(card.dataset.firmwareId, { updateConfigString: false });
                    }
                    setChecklistCompletion(true);
                });
                button.dataset.checklistBound = 'true';
            });
        }

        function initializeProgressStepControls() {
            const progressSteps = document.querySelectorAll('.progress-step[data-step]');

            progressSteps.forEach(stepElement => {
                if (stepElement.dataset.progressBound === 'true') {
                    return;
                }

                const stepNumber = Number(stepElement.dataset.step);
                if (!Number.isFinite(stepNumber)) {
                    return;
                }

                stepElement.setAttribute('role', 'button');
                stepElement.dataset.progressBound = 'true';

                const requestStepChange = (event) => {
                    event.preventDefault();
                    handleProgressStepRequest(stepNumber, stepElement);
                };

                stepElement.addEventListener('click', requestStepChange);
                stepElement.addEventListener('keydown', event => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        requestStepChange(event);
                    }
                });
            });

            updateProgressSteps(currentStep);
        }

        function handleProgressStepRequest(stepNumber, stepElement) {
            const maxReachableStep = getMaxReachableStep();

            if (stepNumber <= maxReachableStep) {
                setStep(stepNumber, { animate: true });
                return;
            }

            showLockedStepNotice(stepNumber, stepElement);
        }

        function showLockedStepNotice(stepNumber, stepElement) {
            const stepLabel = stepElement?.querySelector('.step-label')?.textContent?.trim();
            const labelText = stepLabel ? `Step ${stepNumber} (${stepLabel})` : `Step ${stepNumber}`;
            showToast(`Finish previous steps to unlock ${labelText}.`, { duration: 3000 });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
                // Check browser compatibility
                if (!navigator.serial) {
                    document.getElementById('browser-warning').style.display = 'block';
                }

                syncChecklistCompletion();
                const copyUrlBtn = document.getElementById('copy-firmware-url-btn');
                if (copyUrlBtn && !navigator.clipboard) {
                    copyUrlBtn.title = 'Copy requires Clipboard API support';
                }

                // Add event listeners
                document.querySelectorAll('input[name="mounting"]').forEach(input => {
                    input.addEventListener('change', handleMountingChange);
                });

                document.querySelectorAll('input[name="power"]').forEach(input => {
                    input.addEventListener('change', handlePowerChange);
                });

                document.querySelectorAll('input[name="airiq"]').forEach(input => {
                    input.addEventListener('change', updateConfiguration);
                });

                document.querySelectorAll('input[name="presence"]').forEach(input => {
                    input.addEventListener('change', updateConfiguration);
                });

                document.querySelectorAll('input[name="comfort"]').forEach(input => {
                    input.addEventListener('change', updateConfiguration);
                });

                document.querySelectorAll('input[name="fan"]').forEach(input => {
                    input.addEventListener('change', updateConfiguration);
                });

                initializeProgressStepControls();

                rememberToggleInputs = Array.from(document.querySelectorAll('[data-remember-toggle]'));
                rememberToggleInputs.forEach(input => {
                    input.addEventListener('change', handleRememberToggleChange);
                });

                const rememberEnabled = isRememberEnabled();
                syncRememberToggleState(rememberEnabled);

                const savedConfig = rememberEnabled ? loadRememberedConfiguration() : null;

                initializeFromUrl({ baseConfig: savedConfig });
        });

        function handleMountingChange(e) {
            configuration.mounting = e.target.value;
            document.querySelector('#step-1 .btn-next').disabled = false;

            // Show/hide fan module based on mounting type
            updateFanModuleVisibility();

            updateConfiguration({ skipUrlUpdate: true });
            updateUrlFromConfiguration();
        }

        function handlePowerChange(e) {
            configuration.power = e.target.value;
            document.querySelector('#step-2 .btn-next').disabled = false;
            updateUrlFromConfiguration();
            persistConfigurationSnapshot();
        }

        function updateFanModuleVisibility() {
            const fanSection = document.getElementById('fan-module-section');
            if (configuration.mounting === 'ceiling') {
                fanSection.style.display = 'none';
                // Reset fan selection if ceiling mount
                document.querySelector('input[name="fan"][value="none"]').checked = true;
                configuration.fan = 'none';
            } else {
                fanSection.style.display = 'block';
            }
        }

        function updateConfiguration(options = {}) {
            // Update AirIQ
            const airiqValue = document.querySelector('input[name="airiq"]:checked')?.value || 'none';
            configuration.airiq = airiqValue;

            // Update Presence module
            configuration.presence = document.querySelector('input[name="presence"]:checked')?.value || 'none';

            // Update Comfort module
            configuration.comfort = document.querySelector('input[name="comfort"]:checked')?.value || 'none';

            // Update Fan module (only if wall mount)
            if (configuration.mounting === 'wall') {
                configuration.fan = document.querySelector('input[name="fan"]:checked')?.value || 'none';
            }

            if (!options.skipUrlUpdate) {
                updateUrlFromConfiguration();
            }

            persistConfigurationSnapshot();
        }

        function nextStep() {
            if (currentStep < totalSteps) {
                setStep(currentStep + 1, { animate: true });
            }
        }

        function previousStep() {
            if (currentStep > 1) {
                setStep(currentStep - 1, { animate: true });
            }
        }

        function setStep(targetStep, { skipUrlUpdate = false, animate = true } = {}) {
            if (targetStep < 1 || targetStep > totalSteps) {
                return;
            }

            const previousStep = currentStep;
            const targetStepElement = document.getElementById(`step-${targetStep}`);

            if (!targetStepElement) {
                return;
            }

            if (previousStep !== targetStep) {
                currentStep = targetStep;
            }

            updateProgressSteps(targetStep);

            if (animate && previousStep !== targetStep) {
                animateStepTransition(previousStep, targetStep);
            } else {
                document.querySelectorAll('.wizard-step').forEach(step => {
                    const stepNumber = Number(step.id.replace('step-', ''));
                    if (stepNumber === targetStep) {
                        step.classList.add('active');
                        step.classList.remove('entering', 'leaving');
                    } else {
                        step.classList.remove('active', 'entering', 'leaving');
                    }
                });

                focusStep(targetStepElement);
            }

            if (currentStep === 3) {
                runStepRender(targetStepElement, 3, () => {
                    updateFanModuleVisibility();
                });
            }

            if (currentStep === 4) {
                runStepRender(targetStepElement, 4, () => {
                    updateConfiguration({ skipUrlUpdate: true });
                    updateSummary();
                    findCompatibleFirmware();
                });
            }

            if (!skipUrlUpdate) {
                updateUrlFromConfiguration();
            }
        }

        function updateProgressSteps(targetStep) {
            const maxReachableStep = getMaxReachableStep();

            for (let i = 1; i <= totalSteps; i++) {
                const progressElement = document.querySelector(`.progress-step[data-step="${i}"]`);
                if (!progressElement) continue;

                if (i === targetStep) {
                    progressElement.classList.add('active');
                } else {
                    progressElement.classList.remove('active');
                }

                if (i < targetStep) {
                    progressElement.classList.add('completed');
                } else {
                    progressElement.classList.remove('completed');
                }

                const isReachable = i <= maxReachableStep;
                const isCurrent = i === targetStep;

                progressElement.dataset.reachable = isReachable ? 'true' : 'false';
                progressElement.setAttribute('aria-disabled', isReachable ? 'false' : 'true');
                progressElement.setAttribute('tabindex', isReachable ? '0' : '-1');

                if (isCurrent) {
                    progressElement.setAttribute('aria-current', 'step');
                } else {
                    progressElement.removeAttribute('aria-current');
                }
            }
        }

        function animateStepTransition(fromStep, toStep) {
            const fromElement = fromStep ? document.getElementById(`step-${fromStep}`) : null;
            const toElement = document.getElementById(`step-${toStep}`);

            if (fromElement && fromElement !== toElement) {
                fromElement.classList.add('leaving');
                fromElement.classList.remove('entering');

                const handleLeave = (event) => {
                    if (event.target !== fromElement || event.propertyName !== 'opacity') {
                        return;
                    }

                    clearTimeout(leaveFallback);
                    fromElement.removeEventListener('transitionend', handleLeave);
                    fromElement.classList.remove('leaving');
                };

                const leaveFallback = setTimeout(() => {
                    fromElement.removeEventListener('transitionend', handleLeave);
                    fromElement.classList.remove('leaving');
                }, 450);

                fromElement.addEventListener('transitionend', handleLeave);
                fromElement.classList.remove('active');
            }

            if (!toElement) {
                return;
            }

            toElement.classList.remove('leaving');
            toElement.classList.add('entering');
            toElement.classList.remove('active');

            const activateStep = () => {
                toElement.classList.add('active');

                const handleEnter = (event) => {
                    if (event.target !== toElement || event.propertyName !== 'opacity') {
                        return;
                    }

                    clearTimeout(enterFallback);
                    toElement.removeEventListener('transitionend', handleEnter);
                    toElement.classList.remove('entering');
                    focusStep(toElement);
                };

                const enterFallback = setTimeout(() => {
                    toElement.removeEventListener('transitionend', handleEnter);
                    toElement.classList.remove('entering');
                    focusStep(toElement);
                }, 450);

                toElement.addEventListener('transitionend', handleEnter);
            };

            requestAnimationFrame(activateStep);
        }

        function focusStep(stepElement) {
            if (!stepElement) {
                return;
            }

            const focusableSelector = 'input:not([disabled]), button:not([disabled]), select:not([disabled]), textarea:not([disabled]), [href], [tabindex]:not([tabindex="-1"])';
            const focusable = stepElement.querySelector(focusableSelector);

            if (focusable) {
                focusable.focus();
                return;
            }

            const heading = stepElement.querySelector('h2, h3, h4');
            if (heading) {
                if (!heading.hasAttribute('tabindex')) {
                    heading.setAttribute('tabindex', '-1');
                    heading.addEventListener('blur', () => {
                        heading.removeAttribute('tabindex');
                    }, { once: true });
                }

                heading.focus();
            }
        }

        function updateSummary() {
            let summaryHtml = '<div class="summary-grid">';
            
            // Mounting
            summaryHtml += `
                <div class="summary-item">
                    <div class="summary-label">Mounting Type:</div>
                    <div class="summary-value">${configuration.mounting ? configuration.mounting.charAt(0).toUpperCase() + configuration.mounting.slice(1) : 'Not selected'}</div>
                </div>
            `;
            
            // Power
            summaryHtml += `
                <div class="summary-item">
                    <div class="summary-label">Power Option:</div>
                    <div class="summary-value">${configuration.power ? configuration.power.toUpperCase() : 'Not selected'}</div>
                </div>
            `;
            
            // AirIQ
            if (configuration.airiq !== 'none') {
                const airiqSensors = {
                    'base': ['SGP41', 'SCD41', 'MiCS4514', 'BMP390'],
                    'pro': ['SGP41', 'SCD41', 'MiCS4514', 'BMP390', 'SEN0321', 'SPS30', 'SFA40']
                };
                summaryHtml += `
                    <div class="summary-item">
                        <div class="summary-label">AirIQ Module:</div>
                        <div class="summary-value">${configuration.airiq.charAt(0).toUpperCase() + configuration.airiq.slice(1)}</div>
                        <div class="summary-sensors">Includes: ${airiqSensors[configuration.airiq].join(', ')}</div>
                    </div>
                `;
            }
            
            // Presence
            if (configuration.presence !== 'none') {
                const presenceSensors = {
                    'base': ['SEN0609 mmWave sensor'],
                    'pro': ['SEN0609 mmWave sensor', 'LD2450 24GHz radar']
                };
                summaryHtml += `
                    <div class="summary-item">
                        <div class="summary-label">Presence Module:</div>
                        <div class="summary-value">${configuration.presence.charAt(0).toUpperCase() + configuration.presence.slice(1)}</div>
                        <div class="summary-sensors">Includes: ${presenceSensors[configuration.presence].join(', ')}</div>
                    </div>
                `;
            }
            
            // Comfort
            if (configuration.comfort !== 'none') {
                summaryHtml += `
                    <div class="summary-item">
                        <div class="summary-label">Comfort Module:</div>
                        <div class="summary-value">${configuration.comfort.charAt(0).toUpperCase() + configuration.comfort.slice(1)}</div>
                        <div class="summary-sensors">Includes: SHT40 (Temperature/Humidity), LTR-303 (Light)</div>
                    </div>
                `;
            }
            
            // Fan
            if (configuration.fan !== 'none') {
                const fanTypes = {
                    'pwm': 'Variable speed fan control via PWM',
                    'analog': '0-10V analog fan control'
                };
                summaryHtml += `
                    <div class="summary-item">
                        <div class="summary-label">Fan Module:</div>
                        <div class="summary-value">${configuration.fan.toUpperCase()}</div>
                        <div class="summary-sensors">${fanTypes[configuration.fan]}</div>
                    </div>
                `;
            }
            
            summaryHtml += '</div>';
            document.getElementById('config-summary').innerHTML = summaryHtml;
        }

        function groupLegacyBuilds(builds) {
            const groupsMap = new Map();

            builds.forEach((build, index) => {
                if (!build.config_string) {
                    const model = build.model || 'Unknown Model';
                    const variant = build.variant || '';
                    const key = `${model}||${variant}`;

                    if (!groupsMap.has(key)) {
                        groupsMap.set(key, {
                            model,
                            variant,
                            builds: []
                        });
                    }

                    groupsMap.get(key).builds.push({
                        ...build,
                        manifestIndex: index
                    });
                }
            });

            return Array.from(groupsMap.values()).sort((a, b) => {
                const modelCompare = a.model.localeCompare(b.model);
                if (modelCompare !== 0) {
                    return modelCompare;
                }
                return a.variant.localeCompare(b.variant);
            });
        }

        function renderLegacyFirmware(groups) {
            const section = document.getElementById('legacy-firmware-section');
            const list = document.getElementById('legacy-firmware-list');
            const panel = document.getElementById('legacy-firmware-panel');

            if (!section || !list) {
                return;
            }

            if (!groups.length) {
                section.style.display = 'none';
                list.innerHTML = '';
                if (panel) {
                    panel.removeAttribute('open');
                }
                return;
            }

            const legacyHtml = groups.map(group => {
                const variantTag = group.variant ? `<span class="legacy-group-variant">${group.variant}</span>` : '';
                const buildsHtml = group.builds.map(build => {
                    const versionLabel = build.version ? `v${build.version}${build.channel ? `-${build.channel}` : ''}` : '';
                    const buildDate = build.build_date ? new Date(build.build_date) : null;
                    const buildDateLabel = buildDate && !isNaN(buildDate.getTime()) ? buildDate.toLocaleDateString() : '';
                    const fileSize = Number(build.file_size);
                    const sizeLabel = Number.isFinite(fileSize) && fileSize > 0 ? `${(fileSize / 1024).toFixed(1)} KB` : '';
                    const metaParts = [];
                    if (versionLabel) metaParts.push(versionLabel);
                    if (buildDateLabel) metaParts.push(buildDateLabel);
                    if (sizeLabel) metaParts.push(sizeLabel);
                    const metaHtml = metaParts.length ? `<div class="legacy-build-meta">${metaParts.join(' · ')}</div>` : '';
                    const description = build.description || 'No description available for this firmware build.';

                    return `
                        <div class="legacy-build-card">
                            <div class="legacy-build-info">
                                <div class="legacy-build-name">${group.model}${group.variant ? ` · ${group.variant}` : ''}</div>
                                ${metaHtml}
                                <p class="legacy-build-description">${description}</p>
                            </div>
                            <div class="legacy-build-actions">
                                <esp-web-install-button manifest="firmware-${build.manifestIndex}.json" class="legacy-install-button">
                                    <button slot="activate" class="btn btn-primary btn-small">Install Firmware</button>
                                </esp-web-install-button>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <section class="legacy-build-group">
                        <header class="legacy-group-header">
                            <h4 class="legacy-group-title">${group.model}</h4>
                            ${variantTag}
                        </header>
                        <div class="legacy-builds">
                            ${buildsHtml}
                        </div>
                    </section>
                `;
            }).join('');

            list.innerHTML = legacyHtml;
            section.style.display = 'block';
            attachInstallButtonListeners();
        }

        function clearFirmwareOptions() {
            currentFirmwareOptions = [];
            firmwareOptionsMap = new Map();
            currentFirmwareSelectionId = null;
            window.currentFirmware = null;

            const selector = document.getElementById('firmware-version-select');
            if (selector) {
                selector.innerHTML = '';
                selector.value = '';
            }

            const selectorWrapper = document.getElementById('firmware-selector');
            if (selectorWrapper) {
                selectorWrapper.hidden = true;
            }

            renderSelectedFirmware();
            updateSharedReadyState();
        }

        function getFirmwareId(build) {
            return `firmware-${build.manifestIndex}`;
        }

        function parseVersionParts(version) {
            return String(version || '')
                .split('.')
                .map(part => {
                    const value = parseInt(part, 10);
                    return Number.isFinite(value) ? value : 0;
                });
        }

        function compareVersionsDesc(a, b) {
            const partsA = parseVersionParts(a);
            const partsB = parseVersionParts(b);
            const length = Math.max(partsA.length, partsB.length);

            for (let i = 0; i < length; i++) {
                const valueA = partsA[i] ?? 0;
                const valueB = partsB[i] ?? 0;
                if (valueA !== valueB) {
                    return valueB - valueA;
                }
            }

            return 0;
        }

        function compareFirmwareBuilds(a, b) {
            const orderA = FIRMWARE_CHANNEL_ORDER[a.channel] ?? Number.MAX_SAFE_INTEGER;
            const orderB = FIRMWARE_CHANNEL_ORDER[b.channel] ?? Number.MAX_SAFE_INTEGER;

            if (orderA !== orderB) {
                return orderA - orderB;
            }

            const versionCompare = compareVersionsDesc(a.version, b.version);
            if (versionCompare !== 0) {
                return versionCompare;
            }

            const dateA = Date.parse(a.build_date || '') || 0;
            const dateB = Date.parse(b.build_date || '') || 0;
            if (dateA !== dateB) {
                return dateB - dateA;
            }

            return 0;
        }

        function groupBuildsByConfig(builds) {
            const groups = new Map();

            builds.forEach(build => {
                if (!build.config_string) {
                    return;
                }

                if (!groups.has(build.config_string)) {
                    groups.set(build.config_string, []);
                }

                groups.get(build.config_string).push(build);
            });

            return groups;
        }

        function renderFirmwareSelector() {
            const selector = document.getElementById('firmware-version-select');
            const selectorWrapper = document.getElementById('firmware-selector');

            if (!selector || !selectorWrapper) {
                return;
            }

            selector.innerHTML = '';

            if (!currentFirmwareOptions.length) {
                selectorWrapper.hidden = true;
                return;
            }

            currentFirmwareOptions.forEach(build => {
                const option = document.createElement('option');
                const channelLabel = FIRMWARE_CHANNEL_LABELS[build.channel] || (build.channel ? build.channel : 'Custom');
                const versionLabel = build.version ? `v${build.version}` : 'Unknown version';
                option.value = build.firmwareId;
                option.textContent = `${versionLabel} · ${channelLabel}`;
                selector.appendChild(option);
            });

            selectorWrapper.hidden = false;

            const selectedId = currentFirmwareSelectionId || (selector.options[0] ? selector.options[0].value : '');
            if (selectedId) {
                selector.value = selectedId;
            }
        }

        function setFirmwareOptions(builds, configString) {
            currentFirmwareOptions = Array.isArray(builds) ? builds.slice() : [];
            firmwareOptionsMap = new Map(
                currentFirmwareOptions.map(build => [build.firmwareId, build])
            );

            if (configString) {
                window.currentConfigString = configString;
            }

            if (!currentFirmwareOptions.length) {
                currentFirmwareSelectionId = null;
                window.currentFirmware = null;
            }

            renderFirmwareSelector();
            updateSharedReadyState();
        }

        function selectFirmwareById(firmwareId, options = {}) {
            if (!firmwareId || !firmwareOptionsMap.has(firmwareId)) {
                return;
            }

            const firmware = firmwareOptionsMap.get(firmwareId);
            currentFirmwareSelectionId = firmwareId;
            window.currentFirmware = firmware;

            if (options.updateConfigString !== false && firmware.config_string) {
                window.currentConfigString = firmware.config_string;
            }

            if (options.syncSelector !== false) {
                const selector = document.getElementById('firmware-version-select');
                if (selector) {
                    selector.value = firmwareId;
                }
            }

            if (options.renderDetails !== false) {
                renderSelectedFirmware();
            }

            updateSharedReadyState();
        }

        function selectDefaultFirmware() {
            if (!currentFirmwareOptions.length) {
                currentFirmwareSelectionId = null;
                window.currentFirmware = null;
                renderSelectedFirmware();
                updateSharedReadyState();
                return;
            }

            selectFirmwareById(currentFirmwareOptions[0].firmwareId);
        }

        function escapeHtml(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function renderSelectedFirmware() {
            const container = document.getElementById('compatible-firmware');
            if (!container) {
                return;
            }

            const firmware = window.currentFirmware;

            if (!firmware) {
                container.innerHTML = `
                    <div class="firmware-selection-placeholder">
                        <p>Select a firmware release to see details.</p>
                    </div>
                `;
                attachInstallButtonListeners();
                return;
            }

            const metadataSections = [
                { key: 'features', title: 'Key Features' },
                { key: 'hardware_requirements', title: 'Hardware Requirements' },
                { key: 'known_issues', title: 'Known Issues' },
                { key: 'changelog', title: 'Changelog' }
            ];

            const metadataHtml = metadataSections
                .map(({ key, title }) => {
                    const items = firmware[key];
                    if (!Array.isArray(items) || items.length === 0) {
                        return '';
                    }

                    const listItems = items
                        .map(item => `<li>${escapeHtml(item)}</li>`)
                        .join('');

                    return `
                        <section class="firmware-meta-section firmware-${key.replace(/_/g, '-')}">
                            <h4>${escapeHtml(title)}</h4>
                            <ul>${listItems}</ul>
                        </section>
                    `;
                })
                .filter(Boolean)
                .join('');

            const releaseNotesId = `${firmware.firmwareId}-release-notes`;
            const fileSizeKb = Number(firmware.file_size);
            const sizeLabel = Number.isFinite(fileSizeKb) && fileSizeKb > 0 ? `${(fileSizeKb / 1024).toFixed(1)} KB` : '';
            const buildDate = firmware.build_date ? new Date(firmware.build_date) : null;
            const buildDateLabel = buildDate && !Number.isNaN(buildDate.getTime()) ? buildDate.toLocaleDateString() : '';
            const channelKey = (firmware.channel || 'custom').toString().toLowerCase();
            const channelLabel = escapeHtml(FIRMWARE_CHANNEL_LABELS[channelKey] || firmware.channel || 'Custom');
            const channelClass = `firmware-channel-tag is-${channelKey.replace(/[^a-z0-9-]/g, '-')}`;
            const firmwareName = `Sense360-${firmware.config_string}-v${firmware.version}${firmware.channel ? `-${firmware.channel}` : ''}.bin`;
            const sanitizedConfigString = escapeHtml(firmware.config_string || window.currentConfigString || '');
            const sanitizedVersion = escapeHtml(firmware.version || '');
            const sanitizedChannel = escapeHtml(firmware.channel || '');

            const metaParts = [];
            if (sizeLabel) metaParts.push(`<span class="firmware-size">${escapeHtml(sizeLabel)}</span>`);
            if (buildDateLabel) metaParts.push(`<span class="firmware-date">${escapeHtml(buildDateLabel)}</span>`);

            metaParts.push(`
                <a href="#" class="release-notes-link" data-release-notes-trigger data-release-notes-id="${releaseNotesId}" data-notes-id="${releaseNotesId}" data-firmware-id="${firmware.firmwareId}" data-config-string="${sanitizedConfigString}" data-version="${sanitizedVersion}" data-channel="${sanitizedChannel}" onclick="toggleReleaseNotes(event)">
                    View Release Notes
                </a>
            `);

            const descriptionHtml = firmware.description
                ? `<p class="firmware-description">${escapeHtml(firmware.description)}</p>`
                : '';

            const metadataBlock = metadataHtml
                ? `
                    <div class="firmware-metadata">
                        ${metadataHtml}
                    </div>
                `
                : '';

            container.innerHTML = `
                <div class="firmware-card" data-firmware-detail data-firmware-id="${firmware.firmwareId}" data-channel="${escapeHtml(channelKey)}">
                    <div class="firmware-item">
                        <div class="firmware-info">
                            <div class="firmware-header">
                                <div class="firmware-name">${escapeHtml(firmwareName)}</div>
                                <span class="${channelClass}">${channelLabel}</span>
                            </div>
                            <div class="firmware-details">
                                ${metaParts.join('')}
                            </div>
                            ${descriptionHtml}
                        </div>
                        <div class="firmware-actions">
                            <esp-web-install-button manifest="firmware-${firmware.manifestIndex}.json" data-firmware-id="${firmware.firmwareId}">
                                <button slot="activate" class="btn btn-primary" data-firmware-id="${firmware.firmwareId}">
                                    Install Firmware
                                </button>
                            </esp-web-install-button>
                            <p class="ready-helper" data-ready-helper role="status" aria-live="polite"></p>
                        </div>
                    </div>
                    ${metadataBlock}
                    <div class="release-notes-section" id="${releaseNotesId}" data-release-notes-container data-loaded="false" style="display: none;">
                        <div class="release-notes-content">
                            <div class="loading">Loading release notes...</div>
                        </div>
                    </div>
                </div>
            `;

            attachInstallButtonListeners();
        }

        function updateSharedReadyState() {
            const isReady = !!(
                window.currentFirmware &&
                Array.isArray(window.currentFirmware.parts) &&
                window.currentFirmware.parts.length > 0
            );

            const downloadBtn = document.getElementById('download-btn');
            if (downloadBtn) {
                downloadBtn.disabled = !isReady;
                downloadBtn.classList.toggle('is-ready', isReady);
            }

            const copyUrlBtn = document.getElementById('copy-firmware-url-btn');
            if (copyUrlBtn) {
                const clipboardSupported = !!navigator.clipboard;
                const canCopy = clipboardSupported && isReady;
                copyUrlBtn.disabled = !canCopy;
                copyUrlBtn.classList.toggle('is-ready', canCopy);

                if (!clipboardSupported) {
                    copyUrlBtn.title = 'Copy requires Clipboard API support';
                } else {
                    copyUrlBtn.removeAttribute('title');
                }
            }

            const installButton = document.querySelector('#compatible-firmware esp-web-install-button button[slot="activate"]');
            if (installButton) {
                installButton.classList.toggle('is-ready', isReady);
            }

            const detailHelper = document.querySelector('#compatible-firmware [data-ready-helper]');
            if (detailHelper) {
                if (isReady) {
                    detailHelper.textContent = 'Ready to flash';
                    detailHelper.classList.add('is-visible');
                } else {
                    detailHelper.textContent = '';
                    detailHelper.classList.remove('is-visible');
                }
            }

            const primaryHelper = document.querySelector('.primary-action-group [data-ready-helper]');
            if (primaryHelper) {
                if (isReady) {
                    if (primaryHelper.textContent !== 'Ready to flash') {
                        primaryHelper.textContent = 'Ready to flash';
                    }
                    primaryHelper.classList.add('is-visible');
                } else {
                    primaryHelper.textContent = '';
                    primaryHelper.classList.remove('is-visible');
                }
            }
        }

        async function findCompatibleFirmware() {
            clearFirmwareOptions();

            const selectorWrapper = document.getElementById('firmware-selector');

            if (!configuration.mounting || !configuration.power) {
                if (selectorWrapper) {
                    selectorWrapper.hidden = true;
                }
                document.getElementById('compatible-firmware').innerHTML = `
                    <div class="firmware-error">
                        <h4>Incomplete Configuration</h4>
                        <p>Please select both a mounting location and power option before checking firmware compatibility.</p>
                    </div>
                `;
                attachInstallButtonListeners();
                renderLegacyFirmware([]);
                return;
            }

            const previousConfigString = window.currentConfigString;
            let configString = '';

            configString += `${configuration.mounting.charAt(0).toUpperCase() + configuration.mounting.slice(1)}`;
            configString += `-${configuration.power.toUpperCase()}`;

            configString += formatConfigSegment('airiq', configuration.airiq);
            configString += formatConfigSegment('presence', configuration.presence);
            configString += formatConfigSegment('comfort', configuration.comfort);
            configString += formatConfigSegment('fan', configuration.fan);

            if (previousConfigString !== configString) {
                setChecklistCompletion(false);
            } else {
                syncChecklistCompletion();
            }

            window.currentConfigString = configString;

            try {
                const response = await fetch('manifest.json', { cache: 'no-store' });
                const manifest = await response.json();
                const buildsWithIndex = manifest.builds.map((build, index) => {
                    const enriched = { ...build, manifestIndex: index };
                    enriched.firmwareId = getFirmwareId(enriched);
                    return enriched;
                });

                const groupedByConfig = groupBuildsByConfig(buildsWithIndex);
                const matchingFirmwares = (groupedByConfig.get(configString) || [])
                    .slice()
                    .sort(compareFirmwareBuilds);

                renderLegacyFirmware(groupLegacyBuilds(manifest.builds));

                if (matchingFirmwares.length) {
                    setFirmwareOptions(matchingFirmwares, configString);
                    selectDefaultFirmware();
                } else {
                    const safeConfig = escapeHtml(configString);
                    const notAvailableHtml = `
                        <div class="firmware-not-available">
                            <h4>Firmware Not Available</h4>
                            <p>The firmware for this configuration has not been built yet:</p>
                            <p class="config-string">Sense360-${safeConfig}-v1.0.0-stable.bin</p>
                            <p class="help-text">Please contact support or check back later for this specific configuration.</p>
                        </div>
                    `;
                    document.getElementById('compatible-firmware').innerHTML = notAvailableHtml;
                    if (selectorWrapper) {
                        selectorWrapper.hidden = true;
                    }
                    attachInstallButtonListeners();
                }
            } catch (error) {
                console.error('Error loading manifest:', error);
                const errorHtml = `
                    <div class="firmware-error">
                        <h4>Error Loading Firmware</h4>
                        <p>Unable to check firmware availability. Please try again later.</p>
                    </div>
                `;
                document.getElementById('compatible-firmware').innerHTML = errorHtml;
                if (selectorWrapper) {
                    selectorWrapper.hidden = true;
                }
                attachInstallButtonListeners();
                renderLegacyFirmware([]);
            }
        }

        const firmwareVersionSelect = document.getElementById('firmware-version-select');
        if (firmwareVersionSelect) {
            firmwareVersionSelect.addEventListener('change', event => {
                const firmwareId = event.target.value;
                if (firmwareId) {
                    selectFirmwareById(firmwareId, { syncSelector: false });
                }
            });
        }

        async function toggleReleaseNotes(event) {
            event.preventDefault();
            const trigger = event.currentTarget || event.target;
            const notesId = trigger.dataset.releaseNotesId;
            const firmwareId = trigger.dataset.firmwareId;
            if (!notesId) {
                return;
            }

            const notesSection = document.getElementById(notesId);
            if (!notesSection) {
                return;
            }

            if (firmwareId) {
                selectFirmwareById(firmwareId, { updateConfigString: false, renderDetails: false });
            }

            const isHidden = notesSection.style.display === 'none' || notesSection.style.display === '';
            if (isHidden) {
                notesSection.style.display = 'block';
                trigger.textContent = 'Hide Release Notes';

                if (notesSection.dataset.loaded !== 'true') {
                    await loadReleaseNotesForFirmware(firmwareId, notesSection);
                }
            } else {
                notesSection.style.display = 'none';
                trigger.textContent = 'View Release Notes';
            }
        }

        async function loadReleaseNotesForFirmware(firmwareId, notesSection) {
            const firmware = (firmwareId && firmwareOptionsMap.get(firmwareId)) || window.currentFirmware;
            const configString = firmware ? firmware.config_string : window.currentConfigString;
            const contentRoot = notesSection.querySelector('.release-notes-content');

            if (!firmware || !configString || !contentRoot) {
                if (contentRoot) {
                    contentRoot.innerHTML = `
                        <p class="error">Unable to load release notes.</p>
                    `;
                }
                return;
            }

            try {
                const notesPath = `firmware/configurations/Sense360-${configString}-v${firmware.version}-${firmware.channel}.md`;
                const response = await fetch(notesPath);

                if (response.ok) {
                    const markdown = await response.text();
                    let html = '';
                    const lines = markdown.split('\n');
                    let inList = false;
                    let inParagraph = false;

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();

                        if (inParagraph && (line === '' || line.match(/^#/) || line.match(/^-+/))) {
                            html += '</p>';
                            inParagraph = false;
                        }

                        if (inList && !line.match(/^- /)) {
                            html += '</ul>';
                            inList = false;
                        }

                        if (line.match(/^# /)) {
                            html += `<h2>${line.substring(2)}</h2>`;
                        } else if (line.match(/^## /)) {
                            html += `<h3>${line.substring(3)}</h3>`;
                        } else if (line.match(/^### /)) {
                            html += `<h4>${line.substring(4)}</h4>`;
                        } else if (line.match(/^- /)) {
                            if (!inList) {
                                html += '<ul>';
                                inList = true;
                            }
                            html += `<li>${line.substring(2)}</li>`;
                        } else if (line !== '') {
                            if (!inParagraph) {
                                html += '<p>';
                                inParagraph = true;
                            }
                            html += `${line} `;
                        }
                    }

                    if (inParagraph) html += '</p>';
                    if (inList) html += '</ul>';

                    contentRoot.innerHTML = html;
                } else {
                    contentRoot.innerHTML = `
                        <p class="no-notes">No release notes available for this firmware version.</p>
                    `;
                }
            } catch (error) {
                console.error('Error loading release notes:', error);
                contentRoot.innerHTML = `
                    <p class="error">Unable to load release notes.</p>
                `;
            }

            notesSection.dataset.loaded = 'true';
        }
        
        function downloadFirmware() {
            if (window.currentFirmware && window.currentConfigString) {
                const firmware = window.currentFirmware;
                const configString = window.currentConfigString;
                const firmwarePath = firmware.parts[0].path;

                // Create a link element and trigger download
                const link = document.createElement('a');
                link.href = firmwarePath;
                link.download = `Sense360-${configString}-v${firmware.version}-${firmware.channel}.bin`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function getResolvedFirmwareUrl() {
            if (!window.currentFirmware || !Array.isArray(window.currentFirmware.parts) || window.currentFirmware.parts.length === 0) {
                return null;
            }

            const firmwarePath = window.currentFirmware.parts[0].path;
            if (!firmwarePath) {
                return null;
            }

            try {
                return new URL(firmwarePath, window.location.href).href;
            } catch (error) {
                console.warn('Unable to resolve firmware URL:', error);
                return firmwarePath;
            }
        }

        async function copyFirmwareUrl() {
            if (!navigator.clipboard) {
                showToast('Copy not supported');
                return;
            }

            const firmwareUrl = getResolvedFirmwareUrl();
            if (!firmwareUrl) {
                showToast('Nothing to copy');
                return;
            }

            try {
                await navigator.clipboard.writeText(firmwareUrl);
                showToast('Copied');
            } catch (error) {
                console.error('Failed to copy firmware URL:', error);
                showToast('Copy failed');
            }

            const copyUrlBtn = document.getElementById('copy-firmware-url-btn');
            if (copyUrlBtn) {
                copyUrlBtn.blur();
            }
        }

        function showToast(message, options = {}) {
            const { duration = 2000 } = options;
            let toast = document.getElementById('app-toast');

            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'app-toast';
                toast.className = 'app-toast';
                toast.setAttribute('role', 'status');
                toast.setAttribute('aria-live', 'polite');
                document.body.appendChild(toast);
            }

            toast.textContent = message;

            // Trigger reflow to restart animation when message changes rapidly
            toast.classList.remove('is-visible');
            void toast.offsetWidth;
            toast.classList.add('is-visible');

            if (toastTimeoutId) {
                clearTimeout(toastTimeoutId);
            }

            toastTimeoutId = setTimeout(() => {
                toast.classList.remove('is-visible');
            }, duration);
        }

        function initializeFromUrl(options = {}) {
            const { baseConfig = null } = options;
            const { parsedConfig, providedKeys, parsedStep } = parseConfigurationFromLocation();

            let configToApply;
            const effectiveProvidedKeys = new Set(providedKeys);

            if (baseConfig) {
                configToApply = { ...baseConfig };

                providedKeys.forEach(key => {
                    if (key in parsedConfig) {
                        configToApply[key] = parsedConfig[key];
                    }
                });

                if (effectiveProvidedKeys.size === 0) {
                    Object.keys(baseConfig).forEach(key => {
                        if (baseConfig[key] !== defaultConfiguration[key]) {
                            effectiveProvidedKeys.add(key);
                        }
                    });
                }
            } else {
                configToApply = parsedConfig;
            }

            applyConfiguration(configToApply);

            const maxStep = getMaxReachableStep();
            let targetStep;

            if (parsedStep) {
                targetStep = Math.min(parsedStep, maxStep);
            } else if (!configuration.mounting) {
                targetStep = 1;
            } else if (!configuration.power) {
                targetStep = 2;
            } else if (['airiq', 'presence', 'comfort', 'fan'].some(key => effectiveProvidedKeys.has(key))) {
                targetStep = Math.min(4, maxStep);
            } else {
                targetStep = Math.min(3, maxStep);
            }

            setStep(targetStep, { skipUrlUpdate: true, animate: false });
        }

        function applyConfiguration(initialConfig) {
            Object.assign(configuration, defaultConfiguration, initialConfig);

            if (configuration.mounting) {
                const mountingInput = document.querySelector(`input[name="mounting"][value="${configuration.mounting}"]`);
                if (mountingInput) {
                    mountingInput.checked = true;
                    document.querySelector('#step-1 .btn-next').disabled = false;
                }
            } else {
                document.querySelector('#step-1 .btn-next').disabled = true;
            }

            if (configuration.power) {
                const powerInput = document.querySelector(`input[name="power"][value="${configuration.power}"]`);
                if (powerInput) {
                    powerInput.checked = true;
                    document.querySelector('#step-2 .btn-next').disabled = false;
                }
            } else {
                document.querySelector('#step-2 .btn-next').disabled = true;
            }

            ['airiq', 'presence', 'comfort', 'fan'].forEach(key => {
                const value = configuration[key];
                const input = document.querySelector(`input[name="${key}"][value="${value}"]`);
                if (input) {
                    input.checked = true;
                }
            });

            updateFanModuleVisibility();
            updateConfiguration({ skipUrlUpdate: true });
        }

        function getMaxReachableStep() {
            if (!configuration.mounting) {
                return 1;
            }

            if (!configuration.power) {
                return 2;
            }

            return 4;
        }

        function parseConfigurationFromLocation() {
            const combinedParams = new URLSearchParams();
            const searchParams = new URLSearchParams(window.location.search);
            const hash = window.location.hash.startsWith('#') ? window.location.hash.substring(1) : window.location.hash;
            const hashParams = new URLSearchParams(hash);

            hashParams.forEach((value, key) => {
                combinedParams.set(key, value);
            });

            searchParams.forEach((value, key) => {
                combinedParams.set(key, value);
            });

            const parsedConfig = { ...defaultConfiguration };
            const providedKeys = new Set();

            Object.keys(allowedOptions).forEach(key => {
                const value = combinedParams.get(key);
                if (value && allowedOptions[key].includes(value)) {
                    parsedConfig[key] = value;
                    providedKeys.add(key);
                }
            });

            let parsedStep = null;
            const stepValue = combinedParams.get('step');
            if (stepValue) {
                const numericStep = parseInt(stepValue, 10);
                if (!Number.isNaN(numericStep) && numericStep >= 1 && numericStep <= totalSteps) {
                    parsedStep = numericStep;
                }
            }

            return { parsedConfig, providedKeys, parsedStep };
        }

        function updateUrlFromConfiguration() {
            const params = new URLSearchParams();

            if (configuration.mounting) {
                params.set('mounting', configuration.mounting);
            }

            if (configuration.power) {
                params.set('power', configuration.power);
            }

            params.set('airiq', configuration.airiq || 'none');
            params.set('presence', configuration.presence || 'none');
            params.set('comfort', configuration.comfort || 'none');

            if (configuration.mounting === 'wall') {
                params.set('fan', configuration.fan || 'none');
            } else {
                params.set('fan', 'none');
            }

            params.set('step', String(currentStep));

            const paramString = params.toString();
            const newUrl = paramString ? `${window.location.pathname}?${paramString}` : window.location.pathname;
            history.replaceState(null, '', newUrl);
        }
    </script>
    <script type="module" src="scripts/compat-config.js"></script>
    <script type="module" src="scripts/init-review.js"></script>
    <script src="scripts/theme.js"></script>
    <script src="scripts/theme-toggle.js"></script>
    <script src="scripts/layout/state-summary.js"></script>
    <script src="scripts/layout/firmware-note.js"></script>
    <script src="scripts/layout/init-splitview.js"></script>
</body>
</html>
